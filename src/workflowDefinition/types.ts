/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Any valid JSON Logic data source.
 */
export type JSONLogicSchema = AllOperators | All2;
/**
 * Any valid JSON Logic data source, expect primitive types.
 */
export type AllOperators =
  | Var
  | Missing
  | MissingSome
  | NoName
  | NoName1
  | NoName2
  | NoName3
  | NoName4
  | All1
  | Filter
  | Map
  | Merge
  | None
  | Reduce
  | Some
  | And
  | Equal
  | If
  | NoName5
  | NotEqual
  | NoName6
  | Or
  | StrictEqual
  | StrictNotEqual
  | In
  | Log
  | Method
  | NoName7
  | NoName8
  | NoName9
  | NoName10
  | Max
  | Min
  | Cat
  | Substr;
/**
 * Retrieve data from the provided data object.
 */
export type Var1 =
  | []
  | [Pointer | If]
  | [Pointer | If, Default]
  | Map
  | Merge
  | Filter
  | Reduce
  | Pointer1
  | EntireDataObject
  | Null;
/**
 * Schema to access properties of an object or items of an array by index.
 */
export type Pointer = Property | Index;
/**
 * The key passed to var can use dot-notation to get the property of a property (to any depth you need):
 */
export type Property = string;
/**
 * You can also use the var operator to access an array by numeric index.
 */
export type Index = number;
/**
 * The if statement typically takes 3 arguments: a condition (if), what to do if it’s true (then), and what to do if it’s false (else), like: {"if" : [ true, "yes", "no" ]}.
 * If can also take more than 3 arguments, and will pair up arguments like if/then elseif/then elseif/then else.
 */
export type If =
  | {
      if: OrMoreArgs;
    }
  | {
      '?:': OrMoreArgs;
    };
/**
 * With 1 or more arguments.
 */
export type OrMoreArgs = SingleArray | SingleArg;
/**
 * An array with 1 or more elements.
 */
export type SingleArray = JSONLogicSchema[];
/**
 * Note: 1 or more operators can also take a single, non array argument:
 */
export type SingleArg = AllOperators | All;
/**
 * Any valid JSON data type, except array primitive.
 */
export type All = (boolean | null | number | string) | NoLogic;
/**
 * Any valid JSON object which is not a logic rule.
 */
export type NoLogic =
  | EmptyObject
  | NonLogicSingleKeyObject
  | NonLogicMultipleKeyObject;
export type NonLogicSingleKeyObject = {
  [k: string]: unknown | undefined;
} & {
  [k: string]: unknown | undefined;
};
/**
 * You can supply a default, as the second argument, for values that might be missing in the data object.
 */
export type Default = (boolean | null | number | string | unknown[]) | NoLogic;
/**
 * Up to two args of valid JSON Logic data source.
 */
export type BinaryArg = Array | SingleArg1;
/**
 * An array with one or two elements.
 *
 * @minItems 1
 * @maxItems 2
 */
export type Array = [JSONLogicSchema] | [JSONLogicSchema, JSONLogicSchema];
/**
 * Note: binary operators can also take a single, non array argument:
 */
export type SingleArg1 = AllOperators | All;
/**
 * Up to three args of valid JSON Logic data source.
 */
export type TrinaryArgs = Array1 | SingleArg2;
/**
 * An array with one or three elements.
 *
 * @minItems 1
 * @maxItems 3
 */
export type Array1 =
  | [JSONLogicSchema]
  | [JSONLogicSchema, JSONLogicSchema]
  | [JSONLogicSchema, JSONLogicSchema, JSONLogicSchema];
/**
 * Note: trinary operators can also take a single, non array argument:
 */
export type SingleArg2 = AllOperators | All;
/**
 * Schema to access properties of an object or items of an array by index.
 */
export type Pointer1 = Property | Index;
/**
 * You can also use var with an empty string to get the entire data object – which is really useful in map, filter, and reduce rules.
 */
export type EntireDataObject = '';
/**
 * Unknown null.
 */
export type Null = null;
/**
 * Takes a minimum number of data keys that are required
 */
export type NeedCount = number;
/**
 * Retrieve data from the provided data object.
 */
export type Var2 =
  | []
  | [Pointer | If]
  | [Pointer | If, Default]
  | Map
  | Merge
  | Filter
  | Reduce
  | Pointer1
  | EntireDataObject
  | Null;
/**
 * Only one valid JSON Logic data source.
 */
export type UnaryArg = SingleArray1 | SingleArg3;
/**
 * An array with just one element.
 *
 * @minItems 1
 * @maxItems 1
 */
export type SingleArray1 = [JSONLogicSchema];
/**
 * Note: unary operators can also take a single, non array argument:
 */
export type SingleArg3 = AllOperators | All;
/**
 * Any valid JSON data type.
 */
export type All2 = (boolean | null | number | string | unknown[]) | NoLogic;
/**
 * This interface was referenced by `JustWorkflowItWorkflowDefinition`'s JSON-Schema
 * via the `definition` "definitionsSchema".
 */
export type DefinitionsSchema =
  | {
      workflowInput: DefinitionSchema;
      [k: string]: DefinitionSchema;
    }
  | {
      [k: string]: DefinitionSchema;
    };

export interface JustWorkflowItWorkflowDefinition {
  workflowName: string;
  steps: StepDefinition[];
  definitions: DefinitionsSchema;
}
/**
 * This interface was referenced by `JustWorkflowItWorkflowDefinition`'s JSON-Schema
 * via the `definition` "stepDefinition".
 */
export interface StepDefinition {
  name: string;
  retries?: number;
  timeoutSeconds?: number;
  transitionToStep?:
    | string
    | null
    | {
        /**
         * @minItems 3
         */
        if: [
          JSONLogicSchema,
          JSONLogicSchema,
          JSONLogicSchema,
          ...JSONLogicSchema[],
        ];
      };
  integrationDetails: IntegrationDetails;
}
/**
 * Retrieve data from the provided data object.
 */
export interface Var {
  var: Var1;
}
export interface EmptyObject {
  [k: string]: unknown | undefined;
}
export interface NonLogicMultipleKeyObject {
  [k: string]: unknown | undefined;
}
/**
 * You can use map to perform an action on every member of an array. Note, that inside the logic being used to map, var operations are relative to the array element being worked on.
 */
export interface Map {
  map: BinaryArg;
}
/**
 * Takes one or more arrays, and merges them into one array. If arguments aren’t arrays, they get cast to arrays.
 */
export interface Merge {
  merge: OrMoreArgs;
}
/**
 * You can use filter to keep only elements of the array that pass a test. Note, that inside the logic being used to map, var operations are relative to the array element being worked on.
 */
export interface Filter {
  filter: BinaryArg;
}
/**
 * You can use reduce to combine all the elements in an array into a single value, like adding up a list of numbers. Note, that inside the logic being used to reduce, var operations only have access to an object like: {
 *   "current" : // this element of the array,
 *   "accumulator" : // progress so far, or the initial value
 * }
 */
export interface Reduce {
  reduce: TrinaryArgs;
}
/**
 * Takes an array of data keys to search for (same format as var). Returns an array of any keys that are missing from the data object, or an empty array.
 */
export interface Missing {
  missing: Var1;
}
/**
 * Takes a minimum number of data keys that are required, and an array of keys to search for (same format as var or missing). Returns an empty array if the minimum is met, or an array of the missing keys otherwise.
 */
export interface MissingSome {
  /**
   * @minItems 2
   * @maxItems 2
   */
  missing_some: [NeedCount, Var2];
}
/**
 * Addition. Because addition is associative, it happily take as many args as you want. Passing just one argument to + casts it to a number.
 */
export interface NoName {
  '+': OrMoreArgs;
}
/**
 * Division.
 */
export interface NoName1 {
  '/': BinaryArg;
}
/**
 * Module. Finds the remainder after the first argument is divided by the second argument.
 */
export interface NoName2 {
  '%': BinaryArg;
}
/**
 * Multiplication. Because multiplication is associative, it happily take as many args as you want.
 */
export interface NoName3 {
  '*': OrMoreArgs;
}
/**
 * Subtraction. Passing just one argument to - returns its arithmetic negative (additive inverse).
 */
export interface NoName4 {
  '-': BinaryArg;
}
/**
 * These operations take an array, and perform a test on each member of that array.
 * The most interesting part of these operations is that inside the test code, var operations are relative to the array element being tested.
 * It can be useful to use {"var":""} to get the entire array element within the test.
 */
export interface All1 {
  all: BinaryArg;
}
/**
 * These operations take an array, and perform a test on each member of that array.
 * The most interesting part of these operations is that inside the test code, var operations are relative to the array element being tested.
 * It can be useful to use {"var":""} to get the entire array element within the test.
 */
export interface None {
  none: BinaryArg;
}
/**
 * These operations take an array, and perform a test on each member of that array.
 * The most interesting part of these operations is that inside the test code, var operations are relative to the array element being tested.
 * It can be useful to use {"var":""} to get the entire array element within the test.
 */
export interface Some {
  some: BinaryArg;
}
/**
 * and can be used for simple boolean tests, with 1 or more arguments. At a more sophisticated level, and returns the first falsy argument, or the last argument.
 */
export interface And {
  and: OrMoreArgs;
}
/**
 * Tests equality, with type coercion. Requires two arguments.
 */
export interface Equal {
  '==': BinaryArg;
}
/**
 * Logical negation (“not”). Takes just one argument.
 */
export interface NoName5 {
  '!': UnaryArg;
}
/**
 * Tests not-equal, with type coercion. Requires two arguments.
 */
export interface NotEqual {
  '!=': BinaryArg;
}
/**
 * Double negation, or “cast to a boolean.” Takes a single argument.
 */
export interface NoName6 {
  '!!': UnaryArg;
}
/**
 * or can be used for simple boolean tests, with 1 or more arguments. At a more sophisticated level, or returns the first truthy argument, or the last argument.
 */
export interface Or {
  or: OrMoreArgs;
}
/**
 * Tests strict equality. Requires two arguments.
 */
export interface StrictEqual {
  '===': BinaryArg;
}
/**
 * Tests strict not-equal. Requires two arguments.
 */
export interface StrictNotEqual {
  '!==': BinaryArg;
}
/**
 * If the second argument is an array, tests that the first argument is a member of the array: {"in":[ "Ringo", ["John", "Paul", "George", "Ringo"] ]}.
 * If the second argument is a string, tests that the first argument is a substring: {"in":["Spring", "Springfield"]}.
 */
export interface In {
  in: BinaryArg;
}
/**
 * Logs the first value to console, then passes it through unmodified.
 */
export interface Log {
  log: JSONLogicSchema;
}
/**
 * If your rule needs to call a method on an object, you can use the built-in method operation.
 *  You can also pass an array of arguments into the method.
 */
export interface Method {
  method: OrMoreArgs;
}
/**
 * Greater than.
 */
export interface NoName7 {
  '>': BinaryArg;
}
/**
 * Greater than or equal to.
 */
export interface NoName8 {
  '>=': BinaryArg;
}
/**
 * Less than. You can use a special case of < to test that one value is exclusively between two others.
 */
export interface NoName9 {
  '<': TrinaryArgs;
}
/**
 * Less than or equal to. You can use a special case of <= to test that one value is inclusively between two others.
 */
export interface NoName10 {
  '<=': TrinaryArgs;
}
/**
 * Return the maximum from a list of values.
 */
export interface Max {
  max: OrMoreArgs;
}
/**
 * Return the minimum from a list of values.
 */
export interface Min {
  min: OrMoreArgs;
}
/**
 * Concatenate all the supplied arguments. Note that this is not a join or implode operation, there is no “glue” string.
 */
export interface Cat {
  cat: OrMoreArgs;
}
/**
 * Get a portion of a string.
 *
 * Give a positive start position to return everything beginning at that index (Indexes of course start at zero).
 * Give a negative start position to work backwards from the end of the string, then return everything.
 * Give a positive length to express how many characters to return.
 * Give a negative length to stop that many characters before the end.
 */
export interface Substr {
  substr: TrinaryArgs;
}
/**
 * This interface was referenced by `JustWorkflowItWorkflowDefinition`'s JSON-Schema
 * via the `definition` "integrationDetails".
 */
export interface IntegrationDetails {
  type: string;
  inputTransformer?: JSONXformSchema;
  inputDefinition: RefSchema;
  outputDefinition: RefSchema;
}
/**
 * https://github.com/perpk/json-xform
 *
 * This interface was referenced by `JustWorkflowItWorkflowDefinition`'s JSON-Schema
 * via the `definition` "jsonXformSchema".
 */
export interface JSONXformSchema {
  fieldset: FieldsetSchema[];
}
/**
 * This interface was referenced by `JustWorkflowItWorkflowDefinition`'s JSON-Schema
 * via the `definition` "fieldsetSchema".
 */
export interface FieldsetSchema {
  from?: string;
  to?: string;
  valueToKey?: boolean;
  withValueFrom?: string;
  withTemplate?: string;
  toArray?: boolean;
  via?: {
    type: 'date' | 'commands';
    sourceFormat?: string;
    format?: string;
  };
  fromEach?: {
    field: string;
    to?: string;
    flatten?: boolean;
    fieldset?: FieldsetSchema[];
  };
}
/**
 * This interface was referenced by `JustWorkflowItWorkflowDefinition`'s JSON-Schema
 * via the `definition` "refSchema".
 */
export interface RefSchema {
  $ref: string;
}
/**
 * This interface was referenced by `JustWorkflowItWorkflowDefinition`'s JSON-Schema
 * via the `definition` "definitionSchema".
 */
export interface DefinitionSchema {
  type: string;
  properties?: {
    [k: string]: DefinitionSchema;
  };
  items?: DefinitionSchema;
  required?: string[];
  additionalProperties?: boolean;
}
